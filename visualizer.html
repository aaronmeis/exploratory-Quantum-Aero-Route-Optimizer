<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Aerospace Logistics | Quantum Routing</title>
    <style>
        body,
        html,
        #canvas-container {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
        }

        #fallback-check {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 10px;
            color: #475569;
            pointer-events: none;
            z-index: 50;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            pointer-events: none;
            /* Let clicks pass through to canvas */
        }

        h1 {
            margin: 0;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .status-panel {
            margin-top: 10px;
            font-size: 14px;
            background: rgba(0, 20, 40, 0.7);
            padding: 15px;
            border: 1px solid #00ffff;
            border-radius: 4px;
            width: 300px;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 4px;
        }

        .metric span:last-child {
            font-weight: bold;
        }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }

        button {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }

        button.active {
            background: #ff0055;
            border-color: #ff0055;
            color: white;
            box-shadow: 0 0 20px #ff0055;
        }

        /* Savings Popup */
        #savings-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px #00ff00;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            text-align: center;
            z-index: 10;
        }

        #savings-popup small {
            display: block;
            font-size: 16px;
            color: #fff;
            margin-top: 5px;
        }

        /* Loading Overlay */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            z-index: 100;
            transition: opacity 1s;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>

    <div id="loader">INITIALIZING QUANTUM ROUTING ENGINE...</div>

    <div id="ui-layer">
        <h1>Global Aerospace Logistics</h1>
        <div class="status-panel">
            <div class="metric">
                <span>SYSTEM STATE:</span>
                <span id="state-text" style="color: #ff00ff;">SUPERPOSITION</span>
            </div>
            <div class="metric">
                <span>ROUTES CALCULATED:</span>
                <span id="route-count">1,024,592</span>
            </div>
            <div class="metric">
                <span>GEOPOLITICAL THREAT:</span>
                <span id="threat-level">LOW</span>
            </div>
            <div class="metric">
                <span>FUEL EFFICIENCY:</span>
                <span id="fuel-eff">ANALYZING...</span>
            </div>
        </div>
    </div>

    <div id="savings-popup">
        18% SAVINGS
        <small>OPTIMAL ROUTE LOCKED</small>
    </div>

    <div id="controls">
        <button id="btn-disrupt" onclick="toggleDisruption()">⚠ Simulate Disruption</button>
        <button id="btn-optimize" onclick="optimizeRoutes()">◈ Quantum Optimization</button>
        <button id="btn-reset" onclick="resetSystem()">↺ Reset View</button>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Configuration ---
        const config = {
            earthRadius: 10,
            routeColor: 0x00ffff,
            optimizedColor: 0x00ff00,
            disruptionColor: 0xff0055,
            superpositionCount: 12, // Number of "ghost" paths per route
            rotationSpeed: 0.0005
        };

        // --- State ---
        let state = {
            optimized: false,
            disrupted: false,
            time: 0
        };

        // --- Three.js Globals ---
        let scene, camera, renderer, controls;
        let earth, atmosphere;
        let routeGroups = []; // Array to store route objects { ghosts: [], main: line, start: vec3, end: vec3 }
        let disruptionZone;

        // --- Locations (Lat, Lon) ---
        const locations = {
            London: { lat: 51.5074, lon: -0.1278 },
            Tokyo: { lat: 35.6762, lon: 139.6503 },
            NewYork: { lat: 40.7128, lon: -74.0060 },
            Dubai: { lat: 25.2048, lon: 55.2708 },
            Sydney: { lat: -33.8688, lon: 151.2093 },
            Singapore: { lat: 1.3521, lon: 103.8198 }
        };

        // --- Initialization ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 35);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.minDistance = 15;
            controls.maxDistance = 60;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 20, 30);
            scene.add(sunLight);
            const pointLight = new THREE.PointLight(0x00ffff, 0.5);
            pointLight.position.set(-20, 10, 20);
            scene.add(pointLight);

            createEarth();
            createDisruptionZone();

            // create routes
            createRoute(locations.London, locations.Tokyo);
            createRoute(locations.NewYork, locations.Dubai);
            createRoute(locations.Sydney, locations.Singapore);

            // Handle Resize
            window.addEventListener('resize', onWindowResize, false);

            // Remove loader
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
            }, 1000);

            animate();
        }

        // --- Asset Creation ---

        function createEarth() {
            // Earth Sphere (Black glossy base)
            const geometry = new THREE.SphereGeometry(config.earthRadius, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x050505,
                emissive: 0x001122,
                specular: 0x111111,
                shininess: 50
            });
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);

            // Wireframe Overlay
            const wireGeo = new THREE.WireframeGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: 0x113344, transparent: true, opacity: 0.15 });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            earth.add(wireframe);

            // Atmosphere Glow
            const atmGeo = new THREE.SphereGeometry(config.earthRadius + 1.5, 64, 64);
            const atmMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.05,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            atmosphere = new THREE.Mesh(atmGeo, atmMat);
            scene.add(atmosphere);

            // Add dots for cities
            Object.values(locations).forEach(loc => {
                const pos = latLonToVector3(loc.lat, loc.lon, config.earthRadius);
                const dotGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const dotMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const dot = new THREE.Mesh(dotGeo, dotMat);
                dot.position.copy(pos);
                earth.add(dot); // Add to earth group so they rotate with it
            });
        }

        function createDisruptionZone() {
            // A visual representation of a "No Fly Zone" over central Asia/Russia area roughly
            const geometry = new THREE.SphereGeometry(2.5, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0xff0055,
                transparent: true,
                opacity: 0, // Hidden initially
                emissive: 0x550011,
                wireframe: true
            });
            disruptionZone = new THREE.Mesh(geometry, material);

            // Position roughly over Central Asia
            const pos = latLonToVector3(45, 60, config.earthRadius + 2);
            disruptionZone.position.copy(pos);
            scene.add(disruptionZone);
        }

        function createRoute(startLoc, endLoc) {
            const start = latLonToVector3(startLoc.lat, startLoc.lon, config.earthRadius);
            const end = latLonToVector3(endLoc.lat, endLoc.lon, config.earthRadius);

            const group = {
                ghosts: [],
                mainCurve: null,
                start: start,
                end: end,
                baseControlHeight: start.distanceTo(end) * 0.5 // Higher arc for longer distance
            };

            // Create Superposition "Ghost" Paths
            for (let i = 0; i < config.superpositionCount; i++) {
                const line = createCurveMesh(start, end, group.baseControlHeight, true, i);
                scene.add(line);
                group.ghosts.push({ mesh: line, offsetSeed: Math.random() });
            }

            routeGroups.push(group);
        }

        function createCurveMesh(start, end, height, isGhost, index) {
            // Get midpoint
            const mid = start.clone().add(end).multiplyScalar(0.5).normalize().multiplyScalar(config.earthRadius + height);

            // Add randomness for ghosts
            if (isGhost) {
                const randomOffset = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4
                );
                mid.add(randomOffset);
            }

            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // Save original positions for disruption morphing
            geometry.userData = { originalPoints: points.map(p => p.clone()) };

            const material = new THREE.LineBasicMaterial({
                color: isGhost ? config.routeColor : config.optimizedColor,
                transparent: true,
                opacity: isGhost ? 0.15 : 1.0,
                blending: THREE.AdditiveBlending,
                linewidth: isGhost ? 1 : 3
            });

            return new THREE.Line(geometry, material);
        }

        // --- Animation & Logic ---

        function updateRoutes() {
            const time = performance.now() * 0.001;

            routeGroups.forEach(group => {
                group.ghosts.forEach((ghost, i) => {
                    const positions = ghost.mesh.geometry.attributes.position;
                    const originalPoints = ghost.mesh.geometry.userData.originalPoints;

                    // 1. Quantum Jitter (Visual noise)
                    if (!state.optimized) {
                        for (let j = 1; j < originalPoints.length - 1; j++) { // Don't move start/end
                            const original = originalPoints[j];
                            // Gentle sine wave wobble
                            const wobble = Math.sin(time * 2 + ghost.offsetSeed * 10 + j * 0.5) * 0.1;

                            // Disruption Logic
                            let avoidance = new THREE.Vector3(0, 0, 0);
                            if (state.disrupted) {
                                // Calculate distance from this point to the disruption zone
                                const pointWorldPos = original.clone().applyMatrix4(ghost.mesh.matrixWorld); // Approximate
                                // Simple distance check in local space since earth doesn't rotate mesh-wise, just camera/group
                                const dist = original.distanceTo(disruptionZone.position);

                                if (dist < 6) {
                                    // Push away from disruption center
                                    const dir = original.clone().sub(disruptionZone.position).normalize();
                                    avoidance.add(dir.multiplyScalar((6 - dist) * 1.5));
                                }
                            }

                            positions.setXYZ(
                                j,
                                original.x + wobble + avoidance.x,
                                original.y + wobble + avoidance.y,
                                original.z + wobble + avoidance.z
                            );
                        }
                    } else {
                        // Collapse to single path logic is handled in opacity, 
                        // but we might want to straighten the remaining line slightly
                    }

                    positions.needsUpdate = true;
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateRoutes();

            // Rotate Earth slowly
            // earth.rotation.y += config.rotationSpeed;
            // Atmosphere follows
            // atmosphere.rotation.y += config.rotationSpeed;

            renderer.render(scene, camera);
        }

        // --- Helpers ---

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            return new THREE.Vector3(x, y, z);
        }

        // --- UI Interactions ---

        window.toggleDisruption = function () {
            state.disrupted = !state.disrupted;
            const btn = document.getElementById('btn-disrupt');
            const threatLevel = document.getElementById('threat-level');

            if (state.disrupted) {
                btn.classList.add('active');
                disruptionZone.material.opacity = 0.6;
                threatLevel.innerText = "CRITICAL (ZONE 4)";
                threatLevel.style.color = "#ff0055";

                // If optimized, revert to superposition to show recalculation
                if (state.optimized) resetSystem(false); // Don't reset disruption
            } else {
                btn.classList.remove('active');
                disruptionZone.material.opacity = 0;
                threatLevel.innerText = "LOW";
                threatLevel.style.color = "#00ffff";
            }
        };

        window.optimizeRoutes = function () {
            if (state.optimized) return;
            state.optimized = true;

            document.getElementById('state-text').innerText = "COLLAPSED (OPTIMIZED)";
            document.getElementById('state-text').style.color = "#00ff00";
            document.getElementById('fuel-eff').innerText = "+18.4% SAVINGS";
            document.getElementById('fuel-eff').style.color = "#00ff00";

            // Show popup
            const popup = document.getElementById('savings-popup');
            popup.style.opacity = 1;
            setTimeout(() => popup.style.opacity = 0, 3000);

            // Visual transition
            routeGroups.forEach(group => {
                // Find "best" path - for simulation, we pick a random one in the middle
                const bestIndex = Math.floor(group.ghosts.length / 2);

                group.ghosts.forEach((ghost, index) => {
                    if (index === bestIndex) {
                        // Make this the hero path
                        ghost.mesh.material.opacity = 1;
                        ghost.mesh.material.color.setHex(config.optimizedColor);
                        ghost.mesh.material.linewidth = 3;
                    } else {
                        // Fade others
                        ghost.mesh.material.opacity = 0.02;
                    }
                });
            });
        };

        window.resetSystem = function (fullReset = true) {
            state.optimized = false;

            document.getElementById('state-text').innerText = "SUPERPOSITION";
            document.getElementById('state-text').style.color = "#ff00ff";
            document.getElementById('fuel-eff').innerText = "ANALYZING...";
            document.getElementById('fuel-eff').style.color = "#00ffff";

            if (fullReset) {
                state.disrupted = false;
                document.getElementById('btn-disrupt').classList.remove('active');
                disruptionZone.material.opacity = 0;
                document.getElementById('threat-level').innerText = "LOW";
                document.getElementById('threat-level').style.color = "#00ffff";
            }

            // Restore visuals
            routeGroups.forEach(group => {
                group.ghosts.forEach(ghost => {
                    ghost.mesh.material.opacity = 0.15;
                    ghost.mesh.material.color.setHex(config.routeColor);
                    ghost.mesh.material.linewidth = 1;
                });
            });
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>

</html>